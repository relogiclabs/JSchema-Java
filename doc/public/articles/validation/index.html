<!DOCTYPE html>
<html lang="en-us"><link rel="stylesheet" href="/JSchema-Java/css/style.css" type="text/css" media="all" />
<link rel="stylesheet" href="/JSchema-Java/css/syntax.css" type="text/css" media="all" />
<link rel="icon" href="/JSchema-Java/images/favicon.ico">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script src="/JSchema-Java/js/script.js"></script><body><header>
    <nav class="header" role="navigation">
        <div class="header-left">
            <label for="menu-checkbox">
                <input id="menu-checkbox" type="checkbox" class="menu-checkbox"/>
                <div class="menu-button">
                    <span class="menu-icon icon-bar1"></span>
                    <span class="menu-icon icon-bar2"></span>
                    <span class="menu-icon icon-bar3"></span>
                </div>
            </label>
            <a href="https://www.relogiclabs.com"><img src="/JSchema-Java/images/logo.svg" alt="Relogic Labs"></a>
        </div>
        <div class="header-right">
            <a href="/JSchema-Java">Home</a>
            <a href="/JSchema-Java/api/index.html">API Reference</a>
            <a href="https://github.com/relogiclabs/JSchema-Java">GitHub</a>
        </div>
    </nav>
</header>
<div class="overlay"></div>
<div class="sidebar">
    <ul>
        
        <li class="section-header ">
            <a href="/JSchema-Java/articles/">Articles</a>
        </li>
        
        <li class="section-item ">
            <a href="/JSchema-Java/articles/introduction/">Introduction</a>
        </li>
        
        <li class="section-item ">
            <a href="/JSchema-Java/articles/quickstart/">Quick Start</a>
        </li>
        
        <li class="section-item active">
            <a href="/JSchema-Java/articles/validation/">Validation Syntax</a>
        </li>
        
        <li class="section-item ">
            <a href="/JSchema-Java/articles/directives/">Directives</a>
        </li>
        
        <li class="section-item ">
            <a href="/JSchema-Java/articles/specification/">Specification</a>
        </li>
        
        <li class="section-item ">
            <a href="/JSchema-Java/articles/datatypes/">Data Types</a>
        </li>
        
        <li class="section-item ">
            <a href="/JSchema-Java/articles/functions/">Functions</a>
        </li>
        
        <li class="section-item ">
            <a href="/JSchema-Java/articles/datetime/">Date and Time</a>
        </li>
        
        <li class="section-item ">
            <a href="/JSchema-Java/articles/components/">Components</a>
        </li>
        
        <li class="section-item ">
            <a href="/JSchema-Java/articles/sourcebuild/">Source Build</a>
        </li>
        
        
    </ul>
</div><main>
<div class="content">
    <style>
pre code { font-size: 1.1em; }
</style>
<h1 id="validation-syntax">Validation Syntax</h1>
<p>A JSON document is a structured data format used for the exchange of information between applications. It primarily consists of two types of values: composite values and non-composite values, the latter also referred to as primitive values.</p>
<p>Composite values in a JSON document act as containers. They can hold zero or more composite or non-composite primitive values. These composite values provide the structural framework for organizing data hierarchically within JSON documents. There are two types of composite values allowed in JSON documents: Arrays and Objects.</p>
<p>Conversely, Non-composite values are the atomic data elements in a JSON document. They cannot contain other values within them. There are four types of primitive values supported by JSON specification: Strings, Numbers, Booleans, and Nulls.</p>
<h2 id="validation-format">Validation Format</h2>
<p>A JSON Schema ensures the correctness and consistency of JSON documents, and it also defines the structure and constraints that a JSON document must conform to. It specifies how both composite and non-composite values should be organized and validated the input document based on the rules specified in the schema document. Thus, a key element of JSON Schema is the validation rule syntax, which provides the required instructions for the validation process. A validation rule is typically expressed using the following notations:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="mf">1.</span> <span class="p">[</span><span class="nx">Value</span><span class="p">]</span> <span class="p">[</span><span class="nb">Function</span><span class="o">-</span><span class="nx">Set</span><span class="p">]</span> <span class="p">[</span><span class="nx">DataType</span><span class="o">-</span><span class="nx">Set</span><span class="p">]</span> <span class="p">[</span><span class="nx">Receiver</span><span class="o">-</span><span class="nx">Set</span><span class="p">]</span> <span class="p">[</span><span class="nx">Optional</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="mf">2.</span> <span class="p">[</span><span class="nx">Undefined</span><span class="p">]</span> <span class="p">[</span><span class="nx">Optional</span><span class="p">]</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th>SN</th>
<th>Component</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>Value</code></td>
<td><code>10</code>; <code>&quot;string&quot;</code>; <code>[10, 20, 30]</code>; <code>{ &quot;key1&quot;: &quot;value1&quot; }</code></td>
</tr>
<tr>
<td>2</td>
<td><code>Function-Set</code></td>
<td><code>@range(1, 10)</code>; <code>@length(5, 50) @regex(&quot;[A-Za-z]+&quot;)</code></td>
</tr>
<tr>
<td>3</td>
<td><code>DataType-Set</code></td>
<td><code>#string</code>; <code>#object #null</code>; <code>#number* #array</code></td>
</tr>
<tr>
<td>4</td>
<td><code>Receiver-Set</code></td>
<td><code>&amp;receiver</code>; <code>&amp;anyName</code>; <code>&amp;anyName123</code></td>
</tr>
<tr>
<td>5</td>
<td><code>Value Optional</code></td>
<td><code>10 ?</code>; <code>&quot;string&quot; ?</code>; <code>[10, 20, 30] ?</code></td>
</tr>
<tr>
<td>6</td>
<td><code>Function-Set Optional</code></td>
<td><code>@range(1, 10) ?</code>; <code>@length(5, 50) ?</code></td>
</tr>
<tr>
<td>7</td>
<td><code>DataType-Set Optional</code></td>
<td><code>#string ?</code>; <code>#integer ?</code>; <code>#array ?</code></td>
</tr>
<tr>
<td>8</td>
<td><code>Function-Set DataType-Set</code></td>
<td><code>@range(1, 10) #integer</code>; <code>@length(5, 10) #string</code></td>
</tr>
<tr>
<td>9</td>
<td><code>Function-Set DataType-Set Optional</code></td>
<td><code>@range(1, 10) #integer ?</code>; <code>@length(5, 10) #string ?</code></td>
</tr>
<tr>
<td>10</td>
<td><code>Value Function-Set DataType-Set Receiver-Set Optional</code></td>
<td><code>10 @range(1, 100) #integer &amp;receiver ?</code></td>
</tr>
<tr>
<td>11</td>
<td><code>Undefined</code></td>
<td><code>!</code></td>
</tr>
<tr>
<td>12</td>
<td><code>Undefined Optional</code></td>
<td><code>! ?</code></td>
</tr>
</tbody>
</table>
<p>The syntax used in the 10th row of the table is valid, but not common in real-world scenarios. The constraint function and data type provide redundant validations, considering the validation for value is succeeded. It is generally recommended to specify the data type in all cases except in the previous scenario. Even though the functions may perform precise validations, they are typically designed to accept a broader range of data types.</p>
<p>Therefore, specifying the data type not only makes the schema more definitive for readers, but also generates clear validation errors if the input document does not contain the expected value type. For instance, the <code>@range</code> function is defined for all types of numeric values as well as dates and times. If you only accept integers for a particular field, the <code>@range</code> function without <code>#integer</code> data type cannot ensure this requirement.</p>
<p>Now, let&rsquo;s explore the composition of this notation and its functionalities. In the context of the validation rule, <code>Value</code> refers to a specific input JSON value of the document. This value can be either a composite value (e.g., an object or an array) or a primitive value (e.g., a string or a number).</p>
<p>The inclusion of <code>Value</code> in the validation rule is optional, meaning that you can choose whether or not to specify a particular JSON value for validation. However, when <code>Value</code> is present in the rule, it serves as a requirement, implying that the specified JSON value must match with the input JSON value of the document for the validation to succeed.</p>
<p>The <code>Function-Set</code> is an optional part of the validation rule that can contain one or more function constraints. Function constraints are restrictions or conditions that validate the input JSON value. These functions can be of two types based on their application:</p>
<ol>
<li>Direct functions are applied directly to the target value itself for which the validation rule is defined.</li>
<li>Nested functions are applied to the nested values or nested components within the target value. They are applicable and valid only if the target value is a composite JSON value. An asterisk <code>*</code> is used after the function name to indicate that the constraint function is applied only to the nested values.</li>
</ol>
<p>The validation of the <code>Function-Set</code> as a whole is considered successful only if each function constraint within it succeeds, regardless of its type and application mode.</p>
<table>
<thead>
<tr>
<th>SN</th>
<th>Function Example</th>
<th>Valid Json</th>
<th>Invalid Json</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>@range(1, 10)</code></td>
<td><code>5</code>; <code>8</code>; <code>10</code></td>
<td><code>-1</code>; <code>0</code>; <code>11</code></td>
</tr>
<tr>
<td>2</td>
<td><code>@range*(1, 10)</code></td>
<td><code>[1, 3]</code>; <code>[2, 4, 6, 8, 10]</code></td>
<td><code>[-1, 0, 5, 11]</code></td>
</tr>
<tr>
<td>3</td>
<td><code>@length(1, 15)</code></td>
<td><code>&quot;lorem&quot;</code>; <code>&quot;lorem ipsum&quot;</code></td>
<td><code>&quot;&quot;</code>; <code>&quot;lorem ipsum dolor&quot;</code></td>
</tr>
<tr>
<td>4</td>
<td><code>@length*(1, 15)</code></td>
<td><code>[&quot;lorem&quot;, &quot;lorem ipsum&quot;]</code></td>
<td><code>[&quot;lorem&quot;, &quot;lorem ipsum dolor&quot;]</code></td>
</tr>
</tbody>
</table>
<p>Similar to the <code>Function-Set</code>, the <code>Datatype-Set</code> is also an optional part of the validation rule and can contain one or more data type constraints. Data type constraints specify the expected data types that validate the input JSON value itself or its nested values, depending on whether the value is composite or primitive and whether its application mode is direct or nested. As like function constraints data types can be of two types based on their application:</p>
<ol>
<li>Direct data types are applied directly to the target value itself for which the validation rule is defined.</li>
<li>Nested data type applied to the nested values or nested components within the target value. They are applicable and valid only if the target value is a composite JSON value. An asterisk <code>*</code> is used after the data type name to indicate that the data type is applied only to the nested values.</li>
</ol>
<p>Validation of the <code>Datatype-Set</code> is deemed successful if validation is successful for one of the direct (type 1) data types and one of the nested (type 2) data types. This becomes particularly relevant in several real-world scenarios including those where a composite target value, such as an array or object, is also allowed to be null.</p>
<table>
<thead>
<tr>
<th>SN</th>
<th>Data Type Example</th>
<th>Valid Json</th>
<th>Invalid Json</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>#integer</code></td>
<td><code>5</code>; <code>8</code>; <code>10</code></td>
<td><code>10.5</code>; <code>1E-08</code></td>
</tr>
<tr>
<td>2</td>
<td><code>#integer* #array</code></td>
<td><code>[1, 3]</code>; <code>[2, 4, 6, 8, 10]</code></td>
<td><code>[10, 10.5, 1E-08]</code>; <code>10</code>; <code>null</code></td>
</tr>
<tr>
<td>3</td>
<td><code>#string</code></td>
<td><code>&quot;lorem&quot;</code>; <code>&quot;lorem ipsum&quot;</code></td>
<td><code>100.5</code>; <code>[&quot;a&quot;, &quot;b&quot;]</code>; <code>null</code></td>
</tr>
<tr>
<td>4</td>
<td><code>#string* #array</code></td>
<td><code>[&quot;lorem&quot;, &quot;lorem ipsum&quot;]</code></td>
<td><code>[10, &quot;lorem&quot;]</code>; <code>&quot;lorem&quot;</code>; <code>null</code></td>
</tr>
<tr>
<td>5</td>
<td><code>#integer #float</code></td>
<td><code>5</code>, <code>10.5</code>, <code>1000</code></td>
<td><code>1E-08</code>; <code>&quot;lorem&quot;</code>; <code>false</code>; <code>null</code></td>
</tr>
<tr>
<td>6</td>
<td><code>#array #null</code></td>
<td><code>[10, 20, 30]</code>; <code>null</code></td>
<td><code>10</code>; <code>100.5</code>; <code>&quot;lorem&quot;</code></td>
</tr>
<tr>
<td>7</td>
<td><code>#integer* #float* #array</code></td>
<td><code>[10, 10.5, 100]</code></td>
<td><code>[10, &quot;lorem&quot;, false, null]</code></td>
</tr>
</tbody>
</table>
<p>When defining nested types for values or elements of a composite type, it is recommended to also define the direct type (eg. <code>#array</code> and <code>#object</code>) that not only makes the schema more convenient for readers but also generates more straightforward validation errors if they occur, but it is optional. Moreover, each nested value must belong to one of the nested types specified in the validation rule for the validation to succeed.</p>
<p>The <code>Receiver-Set</code> is also an optional part of the validation rule, and it can consist of one or more receivers. A receiver is identified by its name always prefixed by <code>&amp;</code> and can receive or store the input JSON values of that position. A validation function can accept receivers and validate input based on the received values of the receivers.</p>
<p>Moreover, one receiver can be used in multiple validation rules and one validation rule can contain multiple receivers. This flexibility facilitates the organization and utilization of receivers in a more coherent and readable manner in a schema. Depending on its position a receiver can receive zero or more JSON input values. For instance, if a receiver is placed inside a common element section of an array, it will receive zero value if the array is empty and many values if it contains many elements.</p>
<p>The <code>Optional</code> marker, denoted as <code>?</code>, specifies that the presence of the target value is optional within the input JSON document. If the target value is absent, no validation is performed, and the JSON document is considered valid.</p>
<p>However, if the target value is present, the validation rule must succeed for the document to be considered valid and conform to the Schema. The absence of the <code>Optional</code> specifier requires the target JSON value to be present in the input JSON document for validation to succeed.</p>
<p>In instances where no validation rule (or no parts of the validation rule) is explicitly defined for a target input JSON value, the use of the undefined marker <code>!</code> signifies that any valid JSON value is acceptable for the target. This allows more flexibility in JSON data validation for specific cases.</p>

</div>

    </main><div class="footer">
    <div class="footer-right">
      © Relogic Labs. All rights reserved.
    </div>
</div></body>

</html>